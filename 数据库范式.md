## 数据库范式 Normal Form

#### 第一范式 （1NF）

数据库表中的任何属性都是atomic的。

实体中的某个属性不能有多个值，或者不能有重复的属性。

#### 第二范式 （2NF）

属性完全依赖于主键。（不能存在依赖主关键字的一部分的属性）

所有单关键字的关系都符合第二范式。不符合2NF，只存在于组合关键字的情况下。

如果存在局部依赖（不为2NF），则应该把这部分分离出来作为新的实体。

{学号，课程名称}  ---> {姓名，年龄，成绩，学分}

学号 ---> 姓名，年龄

课程名称 ---> 学分

(1) 数据冗余：

同一门课程由n个学生选修，"学分"就重复n-1次；同一个学生选修了m门课程，姓名和年龄就重复了m-1次。

 (2) 更新异常：

若调整了某门课程的学分，数据表中所有行的"学分"值都要更新，否则会出现同一门课程学分不同的情况。

(3) 插入异常：

假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有"学号"关键字，课程名称和学分也无法记录入数据库。 

(4) 删除异常：

假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常。

#### 第三范式（3NF）

在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。

**第三范式就是属性不依赖于其它非主属性**

所谓传递函数依赖（Transitive functional dependency)，指的是如果存在"A → B → C"的决定关系，则C传递函数依赖于A。

将有函数依赖的表，拆分为多个表。

#### Boyce-Codd Normal Form（BCNF是3NF的改进形式）

在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合鲍依斯-科得范式。

假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：

(仓库ID, 存储物品ID) →(管理员ID, 数量)

(管理员ID, 存储物品ID) → (仓库ID, 数量)

所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：

(仓库ID) → (管理员ID)

(管理员ID) → (仓库ID)

即存在关键字段决定关键字段的情况，所以其不符合BCNF范式。

#### 范式之间的关系

Each normal form is strictly stronger than the previous one

Every 2NF relation is in 1NF

Every 3NF relation is in 2NF

Every BCNF relation is in 3NF

There exist relations that are in 3NF but not in BCNF

BCNF is considered a stronger form of 3NF

The goal is to have each relation in BCNF (or 3NF)

